TODO: aggiungere le funzioni di logging
TODO: aggiungere le funzioni di health check

TODO: creare una nuova tabella per salvare i fixing ovvero costi accordati tra cliente e fornitore ad esempio F0,
 f1,f2,f3, picco, fuori picco costi che vanno sommati a
  PUN(GME) + SPREAD(Contrattuale comunicato dal cliente va legato al pod)

TODO: creare tabella di inserimento per il budget (front-end) e tabella di salvataggio (back-end) per il budget

TODO: Altro/ verifica altro per fare questo bisogna aspettare che quelli di A2A ci dicano come calcolano il costo

TODO: Rimuovere Data Inserimento per i costi in quanto inutile e trasformare la voce annuale/checkModality in un boolean

TODO: Non salvare nel db file che non sono stati analizzati e che hanno dato errori

TODO: Risolvere download bollette

TODO: ‚úÖ Come si calcola la penale per supero potenza?
      Secondo ARERA (Delibera 568/2019 e TIS):
      1Ô∏è‚É£ Supero < 15%
      Se il supero √® inferiore al 15% della potenza impegnata:
      Si paga la quota potenza anche sul supero.
      2Ô∏è‚É£ Supero ‚â• 15%
      Se il supero √® ‚â• 15%:
      Si paga una penale specifica pi√π elevata.

TODO: AGGIUNTA DB:Penale_Reattiva_Capacitiva DOUBLE,
                  Kvarh_Reattiva_Capacitiva_F3 DOUBLE,
                  Penale_Reattiva_Assorbita DOUBLE,
                  Cosphi_F1 DOUBLE,
                  Cosphi_F2 DOUBLE,
                  Penale_Supero_Potenza DOUBLE,
                  Potenza_Impegnata DOUBLE,
                  Potenza_Massima_Rilevata_F1 DOUBLE,
                  Potenza_Massima_Rilevata_F2 DOUBLE,
                  Potenza_Massima_Rilevata_F3 DOUBLE,

TODO: Penale33 e 75 dividere in due per f1 e f2 se no calcolo esce sbagliato, aggiungere altri campi nel db

TODO: Usa il cosœÜ come:indicatore stato salute impianto,trigger di alert per il cliente.



TODO: Penale energia reattiva capacitiva immessa  Penale = kVArhReattivaCapacitivaImmessaInF3 √ó TariffaPenale (‚Ç¨/ùëòùëâùê¥ùëü‚Ñé)
TODO: Tutte le penali sono decise da ARERA

TODO: Implementare possibilit√† di mettere pi√π bollette alla volta e mettere una barra che scorre ogni bolletta analizzata (es. 12 bollette, 0 di 12 ... 1 di 12 ecc..)

TODO: implementare controllo per verificare prima che la bolletta non sia un ricalcolo

TODO: Trimestrale (modality) diventa un campo dove pu√≤ andarci anche l'checkModality,
      annaule (checkModality) diventa un campo a tre vie 0=""  1="annuale" 2="trimestrale".
      Controllo sempre prima il campo "annuale", aggiunta campo Descrizione per controlli interni (es. questo articolo rimane invariato dal 2018)



package miesgroup.mies.webdev.Service.file;

import io.smallrye.common.constraint.Nullable;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import miesgroup.mies.webdev.Model.Periodo;
import miesgroup.mies.webdev.Model.bolletta.BollettaPod;
import miesgroup.mies.webdev.Repository.bolletta.BollettaPodRepo;
import miesgroup.mies.webdev.Repository.file.FileRepo;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;

import java.time.YearMonth;
import java.util.*;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@ApplicationScoped
public class LetturaRicalcoloBolletta {

    @Inject FileRepo fileRepo;
    @Inject BollettaPodRepo bollettaPodRepo;
    @Inject Lettura lettura;
    // ======================================================
// ===============   DTO SEMPLICI   =====================
// ======================================================
    static class VoceMisura { // per il blocco Contatore matricola ...
        String item;    // es.: "Energia Attiva F1", "Energia Reattiva F2", "Potenza F3", "Reattiva Capacitiva Immessa F1"
        Date dataFine; // data fine riga (mappa il mese)
        double consumo;  // kWh / kW / kvarh (numerico)
    }

    static class VocePrezzo { // per Mese Corrente (quadro di dettaglio) e RICALCOLI (mensilizzati)
        String item;    // es.: "Materia energia F1", "Perdite di rete F2", "Dispacciamento", "TRASPORTI_FISSA", "ASOS_VARIABILE", ecc.
        Date   dataFine; // per i ricalcoli: data fine periodo del mese (es. 31.01.2024 -> Gennaio 2024)
        double prezzo;  // ‚Ç¨ per quella voce e mese
    }

// ======================================================
// ===============   API PRINCIPALE   ===================
// ======================================================

    /**
     * Elabora una bolletta con ricalcolo secondo la tua specifica:
     * - usa i Periodo gi√† estratti (range totale e range ricalcolo)
     * - aggiorna letture "Contatore matricola ..." su mesi storici (solo differenze) e salva il mese corrente
     * - salva mese corrente "SPESA PER ..." (con sottovoci)
     * - applica ricalcoli mensili "RICALCOLO PER RETTIFICA ..." (solo differenze)
     */
    @Transactional
    public void processaBollettaConRicalcolo(
            Document document,
            String idPod,
            Periodo periodoTotale,          // es.: 01/01/2024 -> 31/10/2024
            @Nullable Periodo periodoRicalcolo, // es.: 01/01/2024 -> 30/09/2024 (pu√≤ essere null)
            String periodicitaFatturazione  // es.: "Mensile" (gi√† estratta tab POD)
    ) {
        // 1) Mese corrente (dalla fine del range totale)
        String meseCorrente = canonizzaMese(monthNameOf(periodoTotale.getFine()));
        int annoCorrente    = yearOf(periodoTotale.getFine());
        String nomeBolletta = lettura.extractBollettaNome(document);

        // 2) ===== LETTURE BLOCCO "CONTATORE MATRICOLA ..." =====
        List<VoceMisura> misure = extractLettureContatoreAsList(document); // parsing tabelle consumi per mese, F1/F2/F3

        // raggruppa per mese (canonizzato) -> lista voci
        Map<String, List<VoceMisura>> misurePerMese = misure.stream()
                .collect(Collectors.groupingBy(vm -> canonizzaMese(monthNameOf(vm.dataFine)),
                        LinkedHashMap::new, Collectors.toList()));

        // Aggiorna mesi storici; il mese corrente NON lo persistiamo qui (ci pensa saveDataToDatabase)
        for (Map.Entry<String, List<VoceMisura>> e : misurePerMese.entrySet()) {
            String mese = e.getKey();
            boolean isMeseCorrente = meseCorrente.equalsIgnoreCase(mese);

            // per robustezza, calcolo l'anno dal gruppo (se incroci di anno: uso l'anno della prima voce)
            int annoGruppo = e.getValue().isEmpty() ? annoCorrente : yearOf(e.getValue().get(0).dataFine);

            BollettaPod b = bollettaPodRepo.find("idPod = ?1 and mese = ?2 and anno = ?3", idPod, mese, String.valueOf(annoGruppo))
                    .firstResult();
            boolean isNew = false;
            if (b == null) { b = new BollettaPod(); isNew = true; }

            // intestazione base
            b.setIdPod(idPod);
            b.setNomeBolletta(nomeBolletta);
            b.setMese(mese);
            b.setAnno(String.valueOf(annoGruppo));
            b.setMeseAnno(capitalizeFirstThree(mese) + " " + annoGruppo);
            b.setPeriodoInizio(new java.sql.Date(periodoTotale.getInizio().getTime()));
            b.setPeriodoFine(new java.sql.Date(periodoTotale.getFine().getTime()));

            // applica misure
            applyMisureToEntity(b, e.getValue()); // mappa: Energia Attiva/Reattiva/Potenza/Reattiva cap/ind immessa -> F1/F2/F3

            // persistenza
            if (isMeseCorrente) {
                // üîí EVITO di persistere qui per non duplicare il record del mese corrente.
                // Verr√† gestito da saveDataToDatabase (che inserisce/aggiorna il mese corrente con le spese).
            } else {
                // mesi storici: crea se manca, altrimenti la sessione gestisce il dirty-check
                if (isNew) {
                    bollettaPodRepo.persist(b);
                }
            }
        }

        // 3) ===== MESE CORRENTE ‚Äì QUADRO DI DETTAGLIO "SPESA PER ..." (con sottovoci) =====
        // 3) ===== MESE CORRENTE ‚Äì QUADRO DI DETTAGLIO "SPESA PER ..." (con sottovoci) =====

// a) Letture del mese corrente (costruite dalle misure del blocco "Contatore")
        List<VoceMisura> misureMeseCorrente = misurePerMese.getOrDefault(meseCorrente, Collections.emptyList());
        Map<String, Map<String, Map<String, Integer>>> lettureMeseStub = buildLettureStubFromMisure(meseCorrente, misureMeseCorrente);

// b) Spese del mese corrente dal quadro "Spesa per ..."
        Map<String, Map<String, Double>> speseCorrenteRaw = lettura.extractSpesePerMese(document, lettureMeseStub);

// Normalizzo i mesi ed accorpo eventuali duplicati "Ottobre"/"ottobre"
        Map<String, Map<String, Double>> speseCorrente = normalizeAndMergeNested(speseCorrenteRaw);

// c) kWh dal quadro dedicato (se il PDF li espone: Perdite, Picco, ecc.)
        Map<String, Map<String, Double>> kwhEstratti = lettura.extractKwhPerMese(document);

// d) kWh derivati dalle misure "Energia Attiva" (F1/F2/F3) del mese corrente
        Map<String, Map<String, Double>> kwhDaMisureAttiva = kwhFromMisureAttiva(meseCorrente, misureMeseCorrente);

// e) Merge: tengo **tutto** (quadro + misure). In caso di chiavi doppie sommo.
        Map<String, Map<String, Double>> kWhPerMese = mergeNestedDoubleMaps(kwhEstratti, kwhDaMisureAttiva);

// üîé DEBUG
        System.out.println("\n" + "=".repeat(80));
        System.out.println("üì¶ PAYLOAD verso saveDataToDatabase (MESE CORRENTE: " + meseCorrente + ")");
        System.out.println("- LettureMeseStub: " + lettureMeseStub);
        System.out.println("- SpeseCorrente:   " + speseCorrente);
        System.out.println("- kWhPerMese:      " + kWhPerMese);
        System.out.println("=".repeat(80) + "\n");

// Salvataggio (riempie F1/F2/F3, TOT_Att/TOT_R..., f*_kwh, perdite_kwh, ecc.)
        fileRepo.saveDataToDatabase(lettureMeseStub, speseCorrente, idPod, nomeBolletta, periodoTotale, kWhPerMese);

        // 4) ===== RICALCOLI MENSILI "RICALCOLO PER RETTIFICA ..." =====
        if (periodoRicalcolo != null) {
            // (a) Estrai dalla bolletta i dati di ricalcolo -> lista (item, data, prezzo)
            List<VocePrezzo> prezziRicalcolo = extractRicalcoliDettaglioAsList(document);

            // (b) Raggruppo per YearMonth (robusto anche se attraversa anni)
            Map<YearMonth, List<VocePrezzo>> prezziRicPerYM = prezziRicalcolo.stream()
                    .collect(Collectors.groupingBy(v -> ymOf(v.dataFine), LinkedHashMap::new, Collectors.toList()));

            // (c) Applico differenze al DB, mese per mese
            for (Map.Entry<YearMonth, List<VocePrezzo>> en : prezziRicPerYM.entrySet()) {
                YearMonth ym = en.getKey();
                String meseNome = monthNameOf(ym);  // "Gennaio", ...
                String annoStr  = String.valueOf(ym.getYear());

                BollettaPod row = bollettaPodRepo.find("idPod = ?1 and mese = ?2 and anno = ?3", idPod, meseNome, annoStr)
                        .firstResult();
                if (row == null) {
                    // se manca (pu√≤ capitare), lo creo minimale cos√¨ da poter applicare diffs
                    row = new BollettaPod();
                    row.setIdPod(idPod);
                    row.setNomeBolletta(nomeBolletta);
                    row.setMese(meseNome);
                    row.setAnno(annoStr);
                    row.setMeseAnno(capitalizeFirstThree(meseNome) + " " + annoStr);
                    row.setPeriodoInizio(new java.sql.Date(periodoTotale.getInizio().getTime()));
                    row.setPeriodoFine(new java.sql.Date(periodoTotale.getFine().getTime()));
                    bollettaPodRepo.persist(row);
                }

                boolean changed = applyPrezziRicalcoloDiff(row, en.getValue()); // aggiorna SOLO campi diversi
                if (changed) {
                    // Ricalcolo generation = Materia ‚Äì Dispacciamento (stesso criterio del tuo salvataggio)
                    row.setGeneration(round2(nz(row.getSpeseEne()) - nz(row.getDispacciamento())));
                }
            }
        }
    }

// ======================================================
// ===============   PARSING: CONTATORE   ===============
// ======================================================

    /**
     * Estrae le righe dalle tabelle ‚ÄúContatore matricola ...‚Äù
     * (Energia Attiva/Reattiva/Potenza/Cap/Ind immessa).
     * Restituisce un elenco di (item, dataFine, consumo).
     */
    private List<VoceMisura> extractLettureContatoreAsList(Document document) {
        List<VoceMisura> out = new ArrayList<>();
        NodeList lines = document.getElementsByTagName("Line");

        boolean inContatore = false;
        String sezione = null; // "Energia Attiva" | "Energia Reattiva" | "Potenza" | "Energia Reattiva Capacitiva Immessa" | "Energia Reattiva Induttiva Immessa"
        Pattern riga = Pattern.compile(
                "(\\d{2}[./]\\d{2}[./]\\d{4}).*?(\\d{2}[./]\\d{2}[./]\\d{4}).*?Fascia.*?F([123]).*?([0-9.]+(?:,[0-9]+)?)\\s*(kWh|kW|kvarh)",
                Pattern.CASE_INSENSITIVE);

        for (int i = 0; i < lines.getLength(); i++) {
            String t = lines.item(i).getTextContent().trim();

            if (t.startsWith("Contatore matricola")) { inContatore = true; continue; }
            if (!inContatore) continue;

            // stop prima delle spese
            if (t.contains("COSA MI VIENE FATTURATO") || t.startsWith("SPESA PER LA MATERIA ENERGIA")) break;

            String low = t.toLowerCase(Locale.ITALY);
            if (low.contains("energia attiva")) sezione = "Energia Attiva";
            else if (low.contains("energia reattiva capacitiva immessa")) sezione = "Energia Reattiva Capacitiva Immessa";
            else if (low.contains("energia reattiva induttiva immessa")) sezione = "Energia Reattiva Induttiva Immessa";
            else if (low.contains("energia reattiva")) sezione = "Energia Reattiva";
            else if (low.contains("potenza")) sezione = "Potenza";

            Matcher m = riga.matcher(t);
            if (m.find() && sezione != null) {
                Date end = parsePuntata(m.group(2));
                String fascia = "F" + m.group(3);
                double val = toDouble(m.group(4));
                VoceMisura vm = new VoceMisura();
                vm.item = (sezione + " " + fascia).trim();
                vm.dataFine = end;
                vm.consumo = val;
                out.add(vm);
            }
        }
        return out;
    }

    private void applyMisureToEntity(BollettaPod b, List<VoceMisura> voci) {
        for (VoceMisura v : voci) {
            switch (v.item) {
                case "Energia Attiva F1": b.setF1Att(v.consumo); break;
                case "Energia Attiva F2": b.setF2Att(v.consumo); break;
                case "Energia Attiva F3": b.setF3Att(v.consumo); break;

                case "Energia Reattiva F1": b.setF1R(v.consumo); break;
                case "Energia Reattiva F2": b.setF2R(v.consumo); break;
                case "Energia Reattiva F3": b.setF3R(v.consumo); break;

                case "Energia Reattiva Capacitiva Immessa F1": b.setF1RCapI(v.consumo); break;
                case "Energia Reattiva Capacitiva Immessa F2": b.setF2RCapI(v.consumo); break;
                case "Energia Reattiva Capacitiva Immessa F3": b.setF3RCapI(v.consumo); break;

                case "Energia Reattiva Induttiva Immessa F1": b.setF1RIndI(v.consumo); break;
                case "Energia Reattiva Induttiva Immessa F2": b.setF2RIndI(v.consumo); break;
                case "Energia Reattiva Induttiva Immessa F3": b.setF3RIndI(v.consumo); break;

                case "Potenza F1": b.setF1Pot(v.consumo); break;
                case "Potenza F2": b.setF2Pot(v.consumo); break;
                case "Potenza F3": b.setF3Pot(v.consumo); break;
            }
        }
        // totali
        b.setTotAtt(nz(b.getF1Att()) + nz(b.getF2Att()) + nz(b.getF3Att()));
        b.setTotR(nz(b.getF1R()) + nz(b.getF2R()) + nz(b.getF3R()));
        b.setTotRCapI(nz(b.getF1RCapI()) + nz(b.getF2RCapI()) + nz(b.getF3RCapI()));
        b.setTotRIndI(nz(b.getF1RIndI()) + nz(b.getF2RIndI()) + nz(b.getF3RIndI()));
    }

// ======================================================
// ===============   PARSING: RICALCOLI   ===============
// ======================================================

    /**
     * Estrae le voci dei blocchi ‚ÄúRICALCOLO PER RETTIFICA ‚Ä¶‚Äù (Materia/Trasporti/Oneri/Imposte)
     * come lista (item, dataFine, prezzo) per confronto 1:1 con il DB per ogni mese.
     */
    private List<VocePrezzo> extractRicalcoliDettaglioAsList(Document document) {
        List<VocePrezzo> out = new ArrayList<>();
        NodeList lines = document.getElementsByTagName("Line");

        String sezione = null; // MATERIA | TRASPORTI | ONERI | IMPOSTE
        Pattern range = Pattern.compile("(\\d{2}[./]\\d{2}[./]\\d{4}).*?(\\d{2}[./]\\d{2}[./]\\d{4})");
        Pattern euro  = Pattern.compile("‚Ç¨\\s*([-]?[0-9.]+,[0-9]{2})");

        for (int i = 0; i < lines.getLength(); i++) {
            String t = lines.item(i).getTextContent().trim();

            if (t.startsWith("RICALCOLO PER RETTIFICA SPESA PER LA MATERIA ENERGIA")) { sezione = "MATERIA";    continue; }
            if (t.startsWith("RICALCOLO PER RETTIFICA SPESA PER IL TRASPORTO E LA"))    { sezione = "TRASPORTI";  continue; }
            if (t.startsWith("RICALCOLO PER RETTIFICA SPESA PER ONERI DI SISTEMA"))     { sezione = "ONERI";      continue; }
            if (t.startsWith("RICALCOLO PER RETTIFICA IMPOSTE"))                         { sezione = "IMPOSTE";    continue; }

            if (sezione == null) continue;
            if (t.toLowerCase(Locale.ITALY).contains("storno per rettifica")) continue; // salta totali di periodo

            Matcher mr = range.matcher(t);
            Matcher me = euro.matcher(t);
            if (mr.find() && me.find()) {
                Date end = parsePuntata(mr.group(2));
                double val = toDouble(me.group(1));

                String low = t.toLowerCase(Locale.ITALY);
                String item;
                if (sezione.equals("MATERIA")) {
                    if (low.contains("materia energia f1")) item = "Materia energia F1";
                    else if (low.contains("materia energia f2")) item = "Materia energia F2";
                    else if (low.contains("materia energia f3")) item = "Materia energia F3";
                    else if (low.contains("perdite di rete f1")) item = "Perdite F1";
                    else if (low.contains("perdite di rete f2")) item = "Perdite F2";
                    else if (low.contains("perdite di rete f3")) item = "Perdite F3";
                    else if (low.contains("corrispettivi di dispacciamento")) item = "Dispacciamento";
                    else if (low.contains("mercato capacit√† ore fuori")) item = "Fuori Picco";
                    else if (low.contains("mercato capacit√† ore picco")) item = "Picco";
                    else if (low.contains("corrispettivo variabile di vendita energia")) item = "Corrispettivo variabile";
                    else if (low.contains("materia energia")) item = "Materia energia F0"; // righe senza fascia
                    else item = "Materia energia F0";
                } else if (sezione.equals("TRASPORTI")) {
                    if (low.contains("quota fissa")) item = "TRASPORTI_FISSA";
                    else if (low.contains("quota potenza")) item = "TRASPORTI_POTENZA";
                    else if (low.contains("quota variabile")) item = "TRASPORTI_VARIABILE";
                    else if (low.contains("penalit√† energia reattiva") || low.contains("capacitiva immessa")) item = "PENALITA_REATTIVA";
                    else item = "TRASPORTI_TOTALE?"; // non dovrebbe servire qui
                } else if (sezione.equals("ONERI")) {
                    if (low.contains("componente asos") && low.contains("quota fissa")) item = "ASOS_FISSA";
                    else if (low.contains("componente asos") && low.contains("quota potenza")) item = "ASOS_POTENZA";
                    else if (low.contains("componente asos") && low.contains("quota variabile")) item = "ASOS_VARIABILE";
                    else if (low.contains("componente arim") && low.contains("quota fissa")) item = "ARIM_FISSA";
                    else if (low.contains("componente arim") && low.contains("quota potenza")) item = "ARIM_POTENZA";
                    else if (low.contains("componente arim") && low.contains("quota variabile")) item = "ARIM_VARIABILE";
                    else item = "ONERI_ALTRO";
                } else { // IMPOSTE
                    if (low.contains("fino a 200.000")) item = "IMPOSTE_FINO_200K";
                    else if (low.contains("oltre 200.000") && low.contains("1.200.000")) item = "IMPOSTE_200K_1M2";
                    else if (low.contains("oltre 1.200.000")) item = "IMPOSTE_OLTRE_1M2";
                    else if (low.contains("imposta erariale di consumo")) item = "IMPOSTE_CONSUMO_FISSA";
                    else item = "IMPOSTE_ALTRO";
                }

                VocePrezzo vp = new VocePrezzo();
                vp.item = item;
                vp.dataFine = end;
                vp.prezzo = val;
                out.add(vp);
            }
        }
        return out;
    }

    /**
     * Applica SOLO LE DIFFERENZE dal blocco ricalcoli alla entity DB per quel mese.
     * Ritorna true se ha modificato almeno un campo.
     */
    private boolean applyPrezziRicalcoloDiff(BollettaPod b, List<VocePrezzo> vociMese) {
        boolean changed = false;

        // Accumuli temporanei per imposte (se vuoi salvarle come totale mese)
        Double impFino200 = null, imp200_1200 = null, impOltre1200 = null, impConsumoFissa = null;

        for (VocePrezzo v : vociMese) {
            switch (v.item) {
                // ===== Materia energia + perdite + dispacciamento + capacit√† =====
                case "Materia energia F0":       changed |= setDiff(() -> b.getF0Euro(), b::setF0Euro, v.prezzo); break;
                case "Materia energia F1":       changed |= setDiff(() -> b.getF1Euro(), b::setF1Euro, v.prezzo); break;
                case "Materia energia F2":       changed |= setDiff(() -> b.getF2Euro(), b::setF2Euro, v.prezzo); break;
                case "Materia energia F3":       changed |= setDiff(() -> b.getF3Euro(), b::setF3Euro, v.prezzo); break;
                case "Perdite F1":               changed |= setDiff(() -> b.getF1PerdEuro(), b::setF1PerdEuro, v.prezzo); break;
                case "Perdite F2":               changed |= setDiff(() -> b.getF2PerdEuro(), b::setF2PerdEuro, v.prezzo); break;
                case "Perdite F3":               changed |= setDiff(() -> b.getF3PerdEuro(), b::setF3PerdEuro, v.prezzo); break;
                case "Dispacciamento":           changed |= setDiff(() -> b.getDispacciamento(), b::setDispacciamento, v.prezzo); break;
                case "Fuori Picco":              changed |= setDiff(() -> b.getEuroFuoriPicco(), b::setEuroFuoriPicco, v.prezzo); break;
                case "Picco":                    changed |= setDiff(() -> b.getEuroPicco(), b::setEuroPicco, v.prezzo); break;
                case "Corrispettivo variabile":  /* opzionale: mappa se hai un campo dedicato */ break;

                // ===== Trasporti =====
                case "TRASPORTI_FISSA":          changed |= setDiff(() -> b.getQFixTrasp(), b::setQFixTrasp, v.prezzo); break;
                case "TRASPORTI_POTENZA":        changed |= setDiff(() -> b.getQPotTrasp(), b::setQPotTrasp, v.prezzo); break;
                case "TRASPORTI_VARIABILE":      changed |= setDiff(() -> b.getQVarTrasp(), b::setQVarTrasp, v.prezzo); break;
                case "PENALITA_REATTIVA":        changed |= setDiff(() -> b.getPenRCapI(), b::setPenRCapI, v.prezzo); break;

                // ===== Oneri =====
                case "ASOS_FISSA":               changed |= setDiff(() -> b.getQFixOnASOS(), b::setQFixOnASOS, v.prezzo); break;
                case "ASOS_POTENZA":             changed |= setDiff(() -> b.getQPotOnASOS(), b::setQPotOnASOS, v.prezzo); break;
                case "ASOS_VARIABILE":           changed |= setDiff(() -> b.getQEnOnASOS(), b::setQEnOnASOS, v.prezzo); break;
                case "ARIM_FISSA":               changed |= setDiff(() -> b.getQFixOnARIM(), b::setQFixOnARIM, v.prezzo); break;
                case "ARIM_POTENZA":             changed |= setDiff(() -> b.getQPotOnARIM(), b::setQPotOnARIM, v.prezzo); break;
                case "ARIM_VARIABILE":           changed |= setDiff(() -> b.getQEnOnARIM(), b::setQEnOnARIM, v.prezzo); break;

                // ===== Imposte (somma nel campo totale mese, se quello salvi) =====
                case "IMPOSTE_FINO_200K":     impFino200     = v.prezzo; break;
                case "IMPOSTE_200K_1M2":      imp200_1200    = v.prezzo; break;
                case "IMPOSTE_OLTRE_1M2":     impOltre1200   = v.prezzo; break;
                case "IMPOSTE_CONSUMO_FISSA": impConsumoFissa= v.prezzo; break;
                case "IMPOSTE_ALTRO":         /* se serve */ break;
            }
        }

        // Se hai un campo "imposte" unico per mese:
        if (impFino200 != null || imp200_1200 != null || impOltre1200 != null || impConsumoFissa != null) {
            double totImposte = nz(impFino200) + nz(imp200_1200) + nz(impOltre1200) + nz(impConsumoFissa);
            changed |= setDiff(() -> b.getImposte(), b::setImposte, round2(totImposte));
        }

        // Materia totale mese (se vuoi mantenerlo coerente): sommo f0+f1+f2+f3+perdite+picco+fuori picco
        double speseEne = nz(b.getF0Euro()) + nz(b.getF1Euro()) + nz(b.getF2Euro()) + nz(b.getF3Euro())
                + nz(b.getF1PerdEuro()) + nz(b.getF2PerdEuro()) + nz(b.getF3PerdEuro())
                + nz(b.getEuroPicco()) + nz(b.getEuroFuoriPicco());
        changed |= setDiff(() -> b.getSpeseEne(), b::setSpeseEne, round2(speseEne));

        // Trasporti totale (se vuoi mantenerlo coerente): fissa + potenza + variabile (+ eventuali penalit√†)
        double speseTrasp = nz(b.getQFixTrasp()) + nz(b.getQPotTrasp()) + nz(b.getQVarTrasp());
        changed |= setDiff(() -> b.getSpeseTrasp(), b::setSpeseTrasp, round2(speseTrasp));

        // Oneri totale (somma quote ASOS/ARIM)
        double oneri = nz(b.getQFixOnASOS()) + nz(b.getQPotOnASOS()) + nz(b.getQEnOnASOS())
                + nz(b.getQFixOnARIM()) + nz(b.getQPotOnARIM()) + nz(b.getQEnOnARIM());
        changed |= setDiff(() -> b.getOneri(), b::setOneri, round2(oneri));

        return changed;
    }

// ======================================================
// ===============   UTILS   ============================
// ======================================================

    // === Canonizzazione nomi mesi ===
    private static final Map<String, String> MESE_CANON = new HashMap<>();
    static {
        MESE_CANON.put("gennaio", "Gennaio");   MESE_CANON.put("febbraio", "Febbraio");
        MESE_CANON.put("marzo", "Marzo");       MESE_CANON.put("aprile", "Aprile");
        MESE_CANON.put("maggio", "Maggio");     MESE_CANON.put("giugno", "Giugno");
        MESE_CANON.put("luglio", "Luglio");     MESE_CANON.put("agosto", "Agosto");
        MESE_CANON.put("settembre", "Settembre"); MESE_CANON.put("ottobre", "Ottobre");
        MESE_CANON.put("novembre", "Novembre"); MESE_CANON.put("dicembre", "Dicembre");
    }
    private String canonizzaMese(String raw) {
        if (raw == null) return null;
        String k = raw.trim().toLowerCase(Locale.ITALY);
        return MESE_CANON.getOrDefault(k, raw);
    }

    private boolean setDiff(Supplier<Double> getter, java.util.function.DoubleConsumer setter, double nuovo) {
        double old = nz(getter.get());
        if (Math.abs(old - nuovo) > 0.01) { setter.accept(nuovo); return true; }
        return false;
    }
    private static double nz(Double d) { return d != null ? d : 0.0; }
    private static double round2(double v) { return Math.round(v * 100.0) / 100.0; }

    private String capitalizeFirstThree(String mese) {
        if (mese == null || mese.isEmpty()) return mese;
        return mese.substring(0,1).toUpperCase() + mese.substring(1, Math.min(3, mese.length())).toLowerCase();
    }

    private List<String> monthsBetweenInclusive(Date start, Date end) {
        Calendar c = Calendar.getInstance(); c.setTime(start);
        Calendar e = Calendar.getInstance(); e.setTime(end);
        String[] mesi = {"Gennaio","Febbraio","Marzo","Aprile","Maggio","Giugno","Luglio","Agosto","Settembre","Ottobre","Novembre","Dicembre"};
        List<String> out = new ArrayList<>();
        while (!(c.get(Calendar.YEAR) == e.get(Calendar.YEAR) && c.get(Calendar.MONTH) == e.get(Calendar.MONTH))) {
            out.add(mesi[c.get(Calendar.MONTH)]);
            c.add(Calendar.MONTH, 1);
        }
        out.add(mesi[e.get(Calendar.MONTH)]);
        return out;
    }

    private String monthNameOf(Date d) {
        String[] mesi = {"Gennaio","Febbraio","Marzo","Aprile","Maggio","Giugno","Luglio","Agosto","Settembre","Ottobre","Novembre","Dicembre"};
        Calendar c = Calendar.getInstance(); c.setTime(d);
        return mesi[c.get(Calendar.MONTH)];
    }
    private String monthNameOf(YearMonth ym) {
        // ym.getMonth().getDisplayName(TextStyle.FULL, Locale.ITALIAN) sarebbe minuscolo; canonizzo
        String nome = ym.getMonth().getDisplayName(java.time.format.TextStyle.FULL, Locale.ITALIAN);
        return canonizzaMese(nome);
    }
    private YearMonth ymOf(Date d) {
        Calendar c = Calendar.getInstance(); c.setTime(d);
        return YearMonth.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1);
    }

    private int yearOf(Date d) {
        Calendar c = Calendar.getInstance(); c.setTime(d); return c.get(Calendar.YEAR);
    }

    private Date parsePuntata(String ddmmyyyy) {
        String[] p = ddmmyyyy.replace('/', '.').split("\\.");
        return asDate(Integer.parseInt(p[0]), Integer.parseInt(p[1]), Integer.parseInt(p[2]));
    }
    private Date asDate(int dd, int mm, int yy) {
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
        c.set(Calendar.YEAR, yy); c.set(Calendar.MONTH, mm - 1); c.set(Calendar.DAY_OF_MONTH, dd);
        c.set(Calendar.HOUR_OF_DAY, 0); c.set(Calendar.MINUTE, 0); c.set(Calendar.SECOND, 0); c.set(Calendar.MILLISECOND, 0);
        return c.getTime();
    }
    private double toDouble(String s) { return Double.parseDouble(s.replace(".", "").replace(",", ".")); }
    // Costruisce la mappa letture per saveDataToDatabase a partire dalle misure del "Contatore"
    private Map<String, Map<String, Map<String, Integer>>> buildLettureStubFromMisure(
            String meseCorrente,
            List<VoceMisura> misureMese
    ) {
        Map<String, Map<String, Map<String, Integer>>> out = new LinkedHashMap<>();
        Map<String, Map<String, Integer>> catFasce = new LinkedHashMap<>();

        for (VoceMisura vm : misureMese) {
            // vm.item es.: "Energia Attiva F1" / "Energia Reattiva F2" / "Potenza F3" / "Energia Reattiva Capacitiva Immessa F1"
            int lastSpace = vm.item.lastIndexOf(' ');
            if (lastSpace <= 0) continue;
            String categoria = vm.item.substring(0, lastSpace).trim(); // "Energia Attiva"
            String fascia    = vm.item.substring(lastSpace + 1).trim(); // "F1"
            int valore       = (int)Math.round(vm.consumo);

            catFasce.computeIfAbsent(categoria, k -> new LinkedHashMap<>())
                    .merge(fascia, valore, Integer::sum);
        }
        out.put(meseCorrente, catFasce);
        return out;
    }

    // Deriva i kWh per fascia (F1/F2/F3) dal blocco letture del Contatore (Energia Attiva).
// Popola chiavi attese da saveDataToDatabase: "Materia energia f1/f2/f3" e "Materia energia f0" = somma.
    private Map<String, Map<String, Double>> kwhFromMisureAttiva(
            String meseCorrente,
            List<VoceMisura> misureMese
    ) {
        double f1 = 0, f2 = 0, f3 = 0;
        for (VoceMisura vm : misureMese) {
            if (vm.item.startsWith("Energia Attiva ")) {
                if (vm.item.endsWith("F1")) f1 += vm.consumo;
                else if (vm.item.endsWith("F2")) f2 += vm.consumo;
                else if (vm.item.endsWith("F3")) f3 += vm.consumo;
            }
        }
        Map<String, Map<String, Double>> out = new LinkedHashMap<>();
        Map<String, Double> cat = new LinkedHashMap<>();
        if (f1 > 0) cat.put("Materia energia f1", f1);
        if (f2 > 0) cat.put("Materia energia f2", f2);
        if (f3 > 0) cat.put("Materia energia f3", f3);
        double f0 = f1 + f2 + f3;
        if (f0 > 0) cat.put("Materia energia f0", f0); // utile a settare f0_kwh

        out.put(meseCorrente, cat);
        return out;
    }

    // Normalizza mesi ("ottobre" -> "Ottobre") e fonde duplicati sommando i valori
    private Map<String, Map<String, Double>> normalizeAndMergeNested(Map<String, Map<String, Double>> in) {
        Map<String, Map<String, Double>> out = new LinkedHashMap<>();
        if (in == null) return out;
        in.forEach((mese, mappa) -> {
            String mk = canonizzaMese(mese);
            Map<String, Double> dest = out.computeIfAbsent(mk, k -> new LinkedHashMap<>());
            if (mappa != null) {
                mappa.forEach((k, v) -> dest.merge(k, v, Double::sum));
            }
        });
        return out;
    }

    // Merge NON distruttivo di due mappe annidate (somma i Double quando le chiavi coincidono)
    private Map<String, Map<String, Double>> mergeNestedDoubleMaps(
            Map<String, Map<String, Double>> a,
            Map<String, Map<String, Double>> b
    ) {
        Map<String, Map<String, Double>> out = new LinkedHashMap<>();
        if (a != null) {
            a.forEach((mese, mappa) -> {
                out.computeIfAbsent(mese, k -> new LinkedHashMap<>());
                if (mappa != null) mappa.forEach((k, v) -> out.get(mese).merge(k, v, Double::sum));
            });
        }
        if (b != null) {
            b.forEach((mese, mappa) -> {
                out.computeIfAbsent(mese, k -> new LinkedHashMap<>());
                if (mappa != null) mappa.forEach((k, v) -> out.get(mese).merge(k, v, Double::sum));
            });
        }
        return out;
    }
}
